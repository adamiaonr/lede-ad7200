--- c/drivers/net/wireless/ath/wil6210/debugfs.c
+++ b/drivers/net/wireless/ath/wil6210/debugfs.c
@@ -14,12 +14,23 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/pci.h>
 #include <linux/rtnetlink.h>
 #include <linux/power_supply.h>
+#include <linux/hash.h>
+#include <linux/slab.h> /* kmalloc() */
+/* for procfs */
+#include <linux/proc_fs.h>
+/* for linux kernel high-resolution timer */
+#include <linux/interrupt.h>
+#include <linux/hrtimer.h>
+#include <linux/sched.h>
+
+/* ath driver includes */
 #include "wil6210.h"
 #include "wmi.h"
 #include "txrx.h"
@@ -64,7 +75,35 @@
 struct wil6210_priv *my_glob_wil = NULL;
 
 /* global variable to hold 'current' set of SWEEP_DUMP_SIZE individual sweep dumps : global variable fixes a wil6210 crash */
-sweep_dump_t sweep_dump_glob, sweep_dump_glob_show;
+sweep_dump_t sweep_dump_glob, sweep_dump_glob_show, sweep_dump_glob_timer;
+/* buffer that can hold SWEEP_DUMP_BUFFER_NUM sweep dumps */
+#define SWEEP_DUMP_BUFFER_NUM 10
+#define SWEEP_DUMP_BUFFER_SIZE SWEEP_DUMP_BUFFER_NUM * sizeof(sweep_dump_t)
+
+/* proc_dir_entry struct for sweep dump shared memory */
+struct proc_dir_entry *proc_memshare_dir;
+/* sweep dump shared memory addr vars
+	- memory address
+	- memory size
+	- free memory size
+	- memory offset
+*/
+char *sweep_dump_shared_mem_addr = NULL;
+unsigned long sweep_dump_shared_mem_size = 0;
+long int sweep_dump_shared_mem_free_size = 0;
+long int sweep_dump_shared_mem_offset = 0;
+
+/* allocate SWEEP_DUMP_BUFFER_NUM * 5908 bytes of memory in the kernel */
+#define SHARED_MEMORY_SIZE SWEEP_DUMP_BUFFER_NUM * sizeof(sweep_dump_t) // SWEEP_DUMP_BUFFER_NUM * 5908 byte = 59.08 kbyte
+/*  shared memory : */
+#define PROC_MEMSHARE_DIR "sweep_dumps"
+#define PROC_MEMSHARE_INFO "meminfo"
+#define PROC_MMAP_FILE "mmap"
+
+/* for linux kernel high resolution timer : 1000 ms (or 1E9 ns) */
+#define SWEEP_DUMP_TIMER_PERIOD_NS 900000000
+static struct hrtimer sweep_dump_hrtimer;
+static ktime_t sweep_dump_ktime;
 
 /* END SEEMOO ADDITIONS */
 
@@ -1990,6 +2029,77 @@
 	.llseek		= seq_lseek,
 };
 
+/* file operations for '/proc/meminfo' style output for shared memory status */
+static int sweep_dump_proc_show_meminfo(struct seq_file *s, void *v) {
+	seq_printf(s, "%08x %lu %ld\n", __pa(sweep_dump_shared_mem_addr), sweep_dump_shared_mem_size, sweep_dump_shared_mem_free_size);
+	return 0;
+}
+
+static int sweep_dump_proc_meminfo_open(struct inode *inode, struct  file *file) {
+	return single_open(file, sweep_dump_proc_show_meminfo, NULL);
+}
+
+static const struct file_operations fops_sweep_dump_proc_meminfo = {
+	.open 		= sweep_dump_proc_meminfo_open,
+	.release 	= seq_release,
+	.read 		= seq_read,
+	.llseek 	= seq_lseek,
+};
+
+/* 
+	mmap method of fops_sweep_dump_proc_meminfo file_operations struct. 
+	this will be called when mmap(/proc/PROC_MEMSHARE_DIR/PROC_MMAP_FILE) is called on userspace.
+*/
+static int sweep_dump_proc_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long page;
+	page = virt_to_phys((void *) sweep_dump_shared_mem_addr) >> PAGE_SHIFT;
+
+	if (remap_pfn_range(vma, vma->vm_start, page, (vma->vm_end - vma->vm_start), vma->vm_page_prot))
+	{
+		printk(KERN_CRIT "sweep dump remap failed");
+		return -1;
+	}
+
+	vma->vm_flags |= (VM_DONTDUMP|VM_DONTEXPAND);
+	
+	printk(KERN_CRIT "sweep dump remap_pfn_range page:[%lu] ok\n", page);
+	
+	return 0;
+}
+
+/* links /proc/PROC_MEMSHARE_DIR/PROC_MMAP_FILE to sweep_dump_proc_mmap */
+static const struct file_operations fops_sweep_dump_proc_mmap = { 
+	.mmap = sweep_dump_proc_mmap
+};
+
+enum hrtimer_restart sweep_dump_copy_to_shared_mem(struct hrtimer * timer)
+{
+	if(my_glob_wil != NULL && ipc_established) {
+		if(test_bit(WMI_FW_CAPABILITY_MOD_FW, my_glob_wil->fw_capabilities)) {
+			
+			// clear shared memory if full
+			if (sweep_dump_shared_mem_offset >= SWEEP_DUMP_BUFFER_SIZE)
+			{
+				memset((void *) sweep_dump_shared_mem_addr, 0, sweep_dump_shared_mem_size);
+				sweep_dump_shared_mem_offset = 0;
+				sweep_dump_shared_mem_free_size = sweep_dump_shared_mem_size;
+			}
+			// copy the sweep dump
+			wil_memcpy_fromio_32((void *) &sweep_dump_glob_timer, (void * __force) my_glob_wil->csr + HOSTADDR(PTR_MEM_SWEEP_DUMP), sizeof(sweep_dump_t));
+			// copy the sweep dump to shared memory addr, in offsets of sizeof(sweep_dump_t) byte
+			memcpy((void *) (sweep_dump_shared_mem_addr + sweep_dump_shared_mem_offset), (void *) &sweep_dump_glob_timer, sizeof(sweep_dump_t));
+			// increment by sizeof(sweep_dump_t) and reset to 0 if offset exceeds SWEEP_DUMP_BUFFER_SIZE
+			sweep_dump_shared_mem_offset += sizeof(sweep_dump_t);
+			// update free size indicator variable
+			sweep_dump_shared_mem_free_size -= sizeof(sweep_dump_t);
+		} 
+	}
+
+	hrtimer_forward_now(&sweep_dump_hrtimer, sweep_dump_ktime);
+	return HRTIMER_RESTART;
+}
+
 /*----------------*/
 static void wil6210_debugfs_init_blobs(struct wil6210_priv *wil,
 				       struct dentry *dbg)
@@ -2049,6 +2159,65 @@
 	{"sweep_dump_cur", 	0444,   &fops_sweep_dump_cur},
 };
 
+static int wil6210_debugfs_init_shared_memory(
+	struct wil6210_priv *wil,
+	struct dentry *dbg)
+{
+	/* creates a folder under /proc, with name PROC_MEMSHARE_DIR, i.e. /proc/PROC_MEMSHARE_DIR */
+	proc_memshare_dir = proc_mkdir(PROC_MEMSHARE_DIR, NULL);
+	if(!proc_memshare_dir)
+		return -1;
+
+	/* create /proc entry to read meminfo status of the sweep dump shared memory from user space : 
+		- name : PROC_MEMSHARE_DIR, thus becoming /proc/PROC_MEMSHARE_DIR/PROC_MEMSHARE_INFO
+		- mode : 0 (?)
+		- parent dir : /proc/PROC_MEMSHARE_DIR/
+		- fops : defines behavior of syscalls called w/ /proc/PROC_MEMSHARE_DIR/PROC_MEMSHARE_INFO. syscalls defined in fops_sweep_dump_proc_meminfo. 
+		- data : NULL (not relevant)
+	*/
+	if(!proc_create_data(PROC_MEMSHARE_INFO, 0, proc_memshare_dir, &fops_sweep_dump_proc_meminfo, NULL))
+		return -1;
+
+	/* create another proc entry under /proc/PROC_MEMSHARE_DIR/, used to read shared memory : 
+		- name : PROC_MEMSHARE_DIR, so that it becomes /proc/PROC_MEMSHARE_DIR/PROC_MMAP_FILE
+		- mode : 0 (?)
+		- parent dir : /proc/PROC_MEMSHARE_DIR/
+		- fops : syscalls behavior for /proc/PROC_MEMSHARE_DIR/PROC_MMAP_FILE
+		- data : NULL (not relevant)
+	*/	
+	if(!proc_create_data(PROC_MMAP_FILE, 0, proc_memshare_dir, &fops_sweep_dump_proc_mmap, NULL))
+		return -1;
+
+	/* alloc shared memory */
+	sweep_dump_shared_mem_addr = kmalloc(SHARED_MEMORY_SIZE, GFP_KERNEL);
+	if (!sweep_dump_shared_mem_addr)
+	{
+		printk(KERN_CRIT "sweep dump shared memory kmalloc() failed\n");
+		return -1;
+	}
+	else
+	{
+		sweep_dump_shared_mem_size = SHARED_MEMORY_SIZE;
+		sweep_dump_shared_mem_free_size = sweep_dump_shared_mem_size;
+		sweep_dump_shared_mem_offset = 0;
+		memset((void *) sweep_dump_shared_mem_addr, 0, sweep_dump_shared_mem_size);
+
+		printk("sweep dump shared memory kmalloc() succeded : addr: %08x, size: %lu\n", __pa(sweep_dump_shared_mem_addr), sweep_dump_shared_mem_size);
+	}
+
+	// set timer to run every SWEEP_DUMP_TIMER_PERIOD_NS ns
+	sweep_dump_ktime = ktime_set(0, SWEEP_DUMP_TIMER_PERIOD_NS); // seconds, nanoseconds
+	// init the timer : 
+	//	- CLOCK_MONOTONIC 	: clock that always moves forward in time and not tied to 'real' time, e.g., it won't go back or forward based on ntp adjustments
+	//	- HRTIMER_MODE_REL 	: time should be interpreted relative to the current time
+	hrtimer_init(&sweep_dump_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	sweep_dump_hrtimer.function = sweep_dump_copy_to_shared_mem;
+	// start timer
+	hrtimer_start(&sweep_dump_hrtimer, sweep_dump_ktime, HRTIMER_MODE_REL);
+
+	return 0;
+}
+
 static void wil6210_debugfs_init_files(struct wil6210_priv *wil,
 				       struct dentry *dbg)
 {
@@ -2157,15 +2326,25 @@
 
 	wil6210_debugfs_create_ITR_CNT(wil, dbg);
 
+	/* initialize shared memory for sweep dumps */
+	wil6210_debugfs_init_shared_memory(wil, dbg);
+
 	return 0;
 }
 
 void wil6210_debugfs_remove(struct wil6210_priv *wil)
 {
+	int ret = 0;
 	debugfs_remove_recursive(wil->debug);
 	wil->debug = NULL;
 
 	kfree(wil->dbg_data.data_arr);
+	/* free sweep dump shared mem */
+	kfree((char *) sweep_dump_shared_mem_addr);
+	/* cancel sweep dump timer */
+	ret = hrtimer_cancel(&sweep_dump_hrtimer);
+	if (ret) 
+		printk(KERN_CRIT "sweep dump timer still in use\n");
 
 	/* free pmc memory without sending command to fw, as it will
 	 * be reset on the way down anyway
